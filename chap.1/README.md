# 1강 DBMS 아키텍쳐
## - 공짜 밥은 존재할까?

##### 1강 DBMS 아키텍쳐 개요
<p align = "center"><img src = "./dbms_architecutre.PNG" width = "70%"></p>

RDB(Relational Database)는 여러 제품이 있으며, 각각의 특징과 장단점이 있다. 따라서 내부 아키텍처들이 조금씩 다르다. 하지만 RDB로써의 기능을 제공한다는 목적은 모두 동일하다.
모두 관계 모델ㄹ이라는 수학적 이론을 바탕으로 하여 기본적인 구조 자체는 모두 같다.
상기 기름은 DBMS의 일반적인 아키텍처의 개요이다.

~~위 그림은 인터넷에서 퍼온 글이므로 책에 나오는 그림과는 다소 차이가 있다.~~

## DBMS 내부의 기능
#### 1.쿼리 평가 엔진
- 사용자로부터 입력받은 SQL 구문을 분석하고, 기억장치에 접근하는 순서(실행계획)을 결정한다. 쿼리 평가 엔진은 **계획**을 세우고 **실행**하는 핵심기능을 담당하는 모듈이다.

#### 2. 버퍼 매니저
- DBMS는 버퍼라는 메모리 영역을 확보하는데, 이 메모리 영역을 관리하는것이 버퍼 매니저이다. 버퍼 매니저는 디스크 용량 매니저와 함께 연동되어 작동한다.

#### 3. 디스크 용량 매니저
- 데이터의 저장을 관리하며, 데이터의 IO를 제어한다.

#### 4. 트랜잭션 매니저와 락 매니저
- 트랜젝션의 정합성(consistency)을 유지하면서 실행하고, 락 매니저는 데이터에 락을 걸어 다른 요청을 대기시킨다.

#### 5. 리커버리 매니저
- 시스템은 언제나 장애가 발생할 수 있기에, 데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구를 해줘야 하는데, 이 기능을 수행하는 것이 리커버리 매지너이다.

---
성능상의 관점에서 가장 중요한 것은 **쿼리 평가 엔진**이다.

# 2강 DBMS와 버퍼
- 버퍼는 성능에 굉장히 중요한 영향을 미친다.
<p align = "center"><img src = "./Memory-Hierarchy.jpg" width = "70%"></p>

#### 1. 공짜 밥은 존재할까?
- 일반적으로 기억장치는 **기억비용**에 따라 1차부터 3차까지의 계층으로 분류한다. ~~(상기 그림에서는 PROCESSOR계층과 RAM 계층을 1차로 보면 된다.)~~
상위 계층일수록 빠르고, 비싸고, 작다. 하위 계층은 느리고, 싸고, 크다. 따라서 많은 데이터를 영속적으로 저장하려 하면 속도를 잃고, 속도를 얻으려하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드오프가 발생한다.

#### 2. DBMS와 기억장치의 관계
- DMBS는 데이터 저장을 목적으로 하는 미들웨어이다. DBMS가 사용하는 대표적인 기억장치는 다음 2가지이다.
  - 하드디스크
    - 용량, 비용, 성능의 관점에서 대부분 하드디스크를 선택
    - 기억장치 계층에서 2차 기억장치로 분류
  - 메모리
    - 디스크에 비해 높은 비용
  - 버퍼를 활용한 속도 향상
    - DBMS는 성능향상을 위해 일부라도 데이터를 메모리 위에 올린다.
    - SQL 구문의 실행 시간 대부분을 I/O에 사용하기에 디스크의 접근을 줄일 수 있다면 성능 향상을 대폭 이끌어 낼 수 있음.

#### 3. 메모리 위에 있는 두 개의 버퍼
- 데이터 캐시
- 로그 버퍼
  - 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 같은 구문을 받으면, 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.(COMMIT)

##### 성능을 높이기 위하여 시점을 차이를 두는 것이다.
##### DBMS는 저장소의 느림을 어떻게 보완할 것인가를 고민해온 미들웨어이다.

#### 4. 메모리의 성질이 초래하는 트레이드 오프
- 휘발성
  - 메모리는 데이터 영속성이 없고, 전원을 끄면 데이터가 휘발됨.
- 발성의 문제점
  - 데이터의 부정합이 발생.
  - 로그 버퍼 위에 존재하는 데이터가 휘발되어 사라지는 현상을 막기위해 Commit을 사용한다. 
  
#### 5. 시스템 특성에 따른 트레이드오프
- 데이터 캐시와 로그 버퍼의 크기
  - 물리 메모리에 여유가 있다면 데이터 캐시를 되도록 많이 할당할 것을 추천한다.
  - SELECT보다 갱신이 많다면 로그버퍼의 크기를 늘려주는 튜닝이 필요하다.
- 검색과 갱신 중에서 중요한 것
  - 갱신처리가 많으면 로그버퍼를 크게, 검색이 많다면 데이터 캐시를 크게 튜닝하는게 좋다. ~~(때에 따라 다르게 튜닝한다.)~~

#### 6. 추가적인 메모리 영역 '워킹 메모리'
- 3.에서의 버퍼 이외에도 메모리 영역을 하나 더 갖고 있다. 정렬, 해시관련 처리에 사용하는 워킹메모리이다.
  - 정렬은 ORDER BY, GROUP BY, PARTITION 등 기능에 사용
  - 해시는 JOIN에 주로 사용
- 워킹 메모리가 부족하면?
  - JAVA와 같이 예외가 터져서 프로그램이 죽는 등의 심각한 무제는 아니지만, 메모리가 부족해지면 갑자기 느려지는 등의 변화가 생김.
  - DBMS는 '메모리가 부족하더라도 무언가를 처리하려고 노력하는 미들웨어'
  
---

# 3강 DBMS와 실행환경

1. 권한 이양의 죄악
- RDB는 사용자가 데이터에 접근하기 위한 절차(HOW)를 사용자가 아닌 시스템에 맡김. 즉 사용자가 하는 일은 대상(WHAT)을 기술하는 것
- HOW를 의식하지 않고 사용하여 성능문제가 생길 수 있음. RDB를 잘 사용하기 위해서는 내부 절차를 들여다 봐야 한다.

2. 데이터에 접근하는 방법은 어떻게 결정할까?
- `쿼리평가엔진`은 입력받은 SQL을 처음 읽어들이는 모듈이다. 파서, 옵티마이저와 같은 여러 서브모듈로 구성됨.
- Parser
  - 입력받은 SQL의 구문을 분석하여 정형적인 형시으로 변환한다. 프로그래밍 언어의 컴파일 시점에 실행되는 것과 같다.
- Optimizer
  - 옵티마이저는 데이터 접근법을 최적화 한다. DBMS두뇌의 핵심!
  - 인덱스 유무, 데이터 분산, 편향 정도, DBMS 내부 변수등을 고려하여 선택 가능한 많은 실행계획을 작성, 비용을 연산하여 가장 낮은 비용을 가진 실행계획을 선택한다.
- Catalog Manager
  - 옵티마이저에 중요한 정보를 제공하는 역할을 한다.
  - 테이블 또는 인덱스의 통계정보가 저장되어 있다. 통계정보 라고도 부른다.
- Plan Evaludation
  - 옵티마이저가 여러 실행계획을 세운 뒤, 최적의 실행결과를 `선택`하는 역할을 한다.

3. 옵티마이저와 통계 정보
- 카탈로그 매니저가 관리하는 통계정보는 DB엔지니어가 항상 신경 써줘야 하는 부분이다.
- 옵티마이저가 실패하는 패턴 -> 통계정보가 부족한 경우가 대표적이다.
- 카탈로그에 포함되는 통계정보
  - 각 테이블 레코드의 수
  - 각 테이블의 필드 수와 필드의 크기
  - 필드의 Cadinality(값의 개수)
  - 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
  - 필드 내부에 있는 NULL 수
  - 인덱스 정보
  
4. 최적의 실행 계획이 작성되게 하려면?
- 테이블의 데이터가 많이 바뀌면 카탈로그의 통계정보도 함께 갱신해야 한다. 하지만 통계정보갱신은 실행 비용이 굉장하기에 갱신 시점을 확실하게 검토해야 한다.

---

# 4강 실행계획이 SQL 구문의 성능을 결정
1. 실행 계획 확인 방법
- 모든 DBMS는 실행계획을 조사하는 수단을 제공
  - Oracle - set autotrace traceonly
  - Mysql - EXPLAIN EXTENDED SQL [구문]
  - ....
2. Table Full Scan의 실행계획
  - 모든 DBMS 실행계획에 포함되어 있는 내용
    1. 조작 대상 객체
      - 테이블 이외에도 인덱스, 파티션, 시퀀스와 같은 SQL구문으로 조작 할 수 있는 객체라면 무엇이든 올 수 있다.
    2. 객체에 대한 조작의 종류
      - 실행계획에서 가장 중요한 부분이다.
    3. 조작 대상이 되는 레코드 수
      - 각 조작에서 처리되는 레코드 수
      - 옵티마이저는 통계라는 메타정보를 참조하고, 실제 테이블을 보지 않기에, 카탈로그의 통계정보가 갱신되어야 3.의 레코드 수도 변경된다.

3. 인덱스 스캔의 실행계획 (n == 데이터의 양)
  - 시퀀셜 스캔 -> O(n)
  - 인덱스 스캔 -> O(log n)

4. 간단한 테이블 결합의 실행 계획
  - SQL에서 지연이 일어나는 경우는 대부분 결홥과 관련됨
  - 일반적으로 DBMS가 결합을 할 때는 세가지 종류의 알고리즘을 사용
    - Nested Loops -> 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른쪽 테이블에서 찾는 방식(가장 간단한 알고리즘)
    - Sort Merge -> 1. 결합키로 레코드를 정렬, 2. 순차적으로 두개의 테이블 결합. 워킹 메모리 사용
    - Hash -> 결합 키 값을 해시값으로 맵핑하는 방법. 작업용 메모리 영역 사용.
  - 결합의 경우 어떤 테이블에 먼저 접근하는지가 굉장히 중요하다.(먼저 접근하는 테이블을 구동테이블(Driving table)이라고 부른다.)

5. 실행 계획의 중요성
최근 옵티마이저는 꽤 우수하다. 하지만 완벽한것은 아님. 옵티마이저를 과신하여 실행 계획이 참담한 경우가 많다. 또한 옵티마이저에게 정보를 제대로 전달하지 못하는 문제도 있다.
이런 경우, 최후의 튜닝 수단을 사용하는데, 실행계획을 수동으로 변경하는 것이다. 힌트 구를 사용하면 SQL구문에서 옵티마이저에게 강제적으로 명령 할 수 있다.
다만, **실행계획을 변경하려면 어떤 선택지가 있는지를 알아야 한다**.
그리고 그 전에 SQL 구문들이 어떠한 접근경로로 데이터를 검색하는지 아는것이 먼저이다.
어떤 테이블 설정이 효율적인지 알아야 SQL 구문이 주어졌을때 어떤 실행계획이 나올지 예측이 가능하다.
    
---

