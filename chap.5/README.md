# 5장 반복문 - 절차 지향형의 속박

### 14강 - 반복문 의존증

Q. SQL에는 반복문이 왜 없는건가요?
A. 반복문이 없는 것이 좋다고 생각하기 때문
- `SQL` 에는 반복문이 없다.
- `RDB` 를 처음 생각해냈던 Edgar F. Codd는 저서 [Relational Database: a practical foundation for productivity]에서 아래와 같이 말했다.
  - 관계 조작은 관계 전체를 모두 조작의 대상으로 삼는다. 이러한 것의 목적은 반복을 제외하는 것이다. 최종 사용자의 생산성을 생각하면 이러한 조건을 만족해야 한다. 그래야만 응용 프로그래머의 생산성에도 기여할 수 있을 것이다.

#### 1. 내부적으로는 반복문 사용

### 15강 - 반복계의 공포

반복계의 몇몇 장점은 SQL을 잘 몰라도 사용할 수 있는 수준이라는 점, SQL 처리 단순화 가능, 여러 행을 한번에 처리하는 SQL을 포장계라고 부른다. 하지만 유지 보수성이 떨어진다.

#### 1. 반복계의 단점
- 성능 ISSUE
  - 반복계로 구현한 코드는 포장계로 구현한 코드에 성능적으로 이길 수 없다.
  - 완벽하게 진다.
- SQL 실행의 오버 헤드
  - 전처리
    1. SQL 구문을 네트워크로 전송
    2. 데이터베이스 연결
      - 최근에는 application에서 미리 연결을 일정 수 확보하여 이런 오버헤드를 감소시키는 `Connection Pool` 이라는 기술을 사용한다.
    3. SQL 구문 파스
    4. SQL 구문의 실행 계획 생성 또는 평가
  - 후처리
    5. 결과 집합을 네트워크로 전송

  - SQL을 여러 번 반복하는 반복계에서는 오버헤드가 높아질 수밖에 없다.

- 병렬 분산이 어렵다.
  - 반복계에서 실행하는 SQL 구분은 대부분 단순해서 1회의 SQL구문이 접근하는 데이터 양이 적다.
    - 반복계는 리소스 사용 효율이 나쁨

- 데이터베이스의 진화로 인한 혜택을 받을 수 없다.
  - 포장계의 SQL 구문은 튜닝 가능성이 굉장히 높으므로 제대로 튜닝만 한다면 처음과 비교해서 현격한 성능 차이가 있다.
  - 반복계는 단지 느리기만 한 것이 아니라 느린 구문을 **튜닝할 수 있는 가능성도 거의 없다**

#### 2. 반복계를 빠르게 만드는 방법은 없을까?

- 반복계를 포장계로 다시 작성
  - 애플리케이션의 수정

- 각각의 SQL을 빠르게 수정
  - SQL구문은 매우 단순하다.
  - 실행계획을 보면 `Unique scan` 또는 `Index range scan` 정도 뿐이다.
  - `INSERT` 구문은 `SELECT` 구문보다 고속화가 더 어렵다.

- 다중화 처리

리소스에 여유가 있고, 처리를 나눌 수 있는 키가 명확하게 정해져있다면, 처리를 다중화해서 성능을 선형에 가깝게 스케일할 수 있다.

#### 3. 반복계의 장점

- 실행 계획의 안정성
  - 변동 위험이 거의 없다
    - 실행 계획 변동에서 가장 골칫거리가 되는 것이 바로 결합 알고리즘의 변경이기 때문

- 예상 처리 시간의 정밀도
  - <처리시간> = <한 번의 실행 시간> X <실행 횟수>

- 트랜젝션 제어가 편리
  - 트랜젝션의 정밀도를 미세하게 제어 가능
  - 특정 반복마다 커밋을 한다고 할 때, 중간에 커밋을 했으므로 해당 지점 근처에서 다시 처리를 실행하면 된다.
    - 포장계에서는 불가능하고, 포장계는 처리를 처음부터 다시 실행해야 한다.

